name: Deploy Alpha

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: "Branch to deploy alpha from (e.g. main, feature/foo)"
        required: false
        default: ""

concurrency:
  group: deploy-alpha-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  deploy-alpha:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.target_branch || github.ref_name }}

      - name: Update .toc Interface versions (latest 3)
        run: |
          set -euo pipefail
          python scripts/update_toc_interface.py --toc LariasWeeklyChecklist_Localization.toc --count 3

      - name: Compute alpha version
        id: ver
        run: |
          set -euo pipefail
          git fetch --tags --force

          TOC="LariasWeeklyChecklist_Localization.toc"
          BRANCH_NAME="${{ inputs.target_branch || github.ref_name }}"

          # Read MAJOR.MINOR.PATCH from the toc (strip any pre-release suffix).
          RAW=$(grep "^## Version:" "$TOC" | sed 's/## Version:[[:space:]]*//')
          if [[ "$RAW" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
          else
            echo "ERROR: could not parse version: $RAW"; exit 1
          fi

          # Find the latest alpha tag for this exact MAJOR.MINOR.PATCH and bump
          # only the build (4th) component.  If no matching tag exists, start at 1.
          LATEST=$(git tag --list "v${MAJOR}.${MINOR}.${PATCH}.*-alpha" --sort=-v:refname | head -n 1 || true)
          if [ -n "${LATEST:-}" ]; then
            BASE="${LATEST#v}"; BASE="${BASE%-alpha}"
            IFS='.' read -r _ _ _ BUILD <<< "$BASE"
            BUILD=${BUILD:-0}
            BUILD=$((BUILD + 1))
          else
            BUILD=1
          fi

          ALPHA_VERSION="${MAJOR}.${MINOR}.${PATCH}.${BUILD}-alpha"
          echo "alpha=$ALPHA_VERSION"  >> "$GITHUB_OUTPUT"
          echo "tag=v$ALPHA_VERSION"   >> "$GITHUB_OUTPUT"
          echo "branch=$BRANCH_NAME"   >> "$GITHUB_OUTPUT"

          # Skip if no Locales/ changes since the last tag (any alpha or stable).
          # workflow_dispatch always proceeds regardless.
          SKIP=false
          if [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            LAST_ANY=$(git tag --list 'v*' --sort=-v:refname \
              | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+-alpha)?$' | head -n 1 || true)
            if [ -n "${LAST_ANY:-}" ]; then
              if git diff --quiet "${LAST_ANY}"..HEAD -- Locales/; then
                echo "No Locales/ changes since ${LAST_ANY}; skipping alpha release."
                SKIP=true
              fi
            fi
          fi
          echo "skip=$SKIP" >> "$GITHUB_OUTPUT"

      - name: Tag alpha (no branch commit)
        if: steps.ver.outputs.skip != 'true'
        env:
          ALPHA_VERSION: ${{ steps.ver.outputs.alpha }}
          TAG:           ${{ steps.ver.outputs.tag }}
        run: |
          set -euo pipefail
          TOC="LariasWeeklyChecklist_Localization.toc"

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Update toc for this build.  Commit on a detached HEAD so the source
          # branch is never touched -- only the tag carries the change.
          sed -i "s/^## Version:.*/## Version: $ALPHA_VERSION/" "$TOC"
          sed -i "s/^## Title:.*/## Title: Larias's Weekly Checklist Localization (ALPHA)/" "$TOC"

          git checkout --detach HEAD
          git add "$TOC"
          git commit -m "Alpha release: $ALPHA_VERSION"

          # Guard against a concurrent run that already pushed this tag.
          if git ls-remote --tags origin "refs/tags/$TAG" | grep -q .; then
            echo "Tag $TAG already exists on remote; skipping."
            exit 0
          fi

          git tag -a "$TAG" -m "Alpha Release $ALPHA_VERSION"
          git push origin "$TAG"

      - name: Package + Upload (CurseForge & Wago)
        if: steps.ver.outputs.skip != 'true'
        uses: BigWigsMods/packager@v2.4.3
        env:
          CF_API_KEY: ${{ secrets.CF_API_KEY }}
          WAGO_API_TOKEN: ${{ secrets.WAGO_API_TOKEN }}

      - name: Notify Discord (alpha deployed)
        if: steps.ver.outputs.skip != 'true' && success()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TAG:     ${{ steps.ver.outputs.tag }}
          BRANCH:  ${{ steps.ver.outputs.branch }}
          REPO:    ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail

          RELEASE_URL="https://github.com/${REPO}/releases/tag/${TAG}"
          CF_ID=$(sed -n 's/^curse-project-id:[[:space:]]*//p' .pkgmeta | head -n 1 | tr -d '[:space:]' || true)
          if [ -z "${CF_ID:-}" ]; then CF_ID=0; fi
          CURSE_URL=""
          if [ "${CF_ID}" != "0" ]; then
            SLUG=$(curl -sS -H "x-api-key: ${CF_API_KEY:-}" "https://api.curseforge.com/v1/mods/${CF_ID}" \
              | python3 -c "import sys,json; data=json.load(sys.stdin).get('data') or {}; print(data.get('slug',''))" 2>/dev/null || true)
            if [ -n "${SLUG:-}" ]; then
              CURSE_URL="https://www.curseforge.com/wow/addons/${SLUG}"
            fi
          fi

          payload=$(cat <<EOF
          {
            "content": " **Larias's Weekly Checklist Localization ${TAG}** (ALPHA from \`${BRANCH}\`) is ready!\n\n GitHub: ${RELEASE_URL}${CURSE_URL:+\n CurseForge: ${CURSE_URL}}\n Workflow: ${RUN_URL}"
          }
          EOF
          )

          curl -sS -H "Content-Type: application/json" \
            -d "$payload" \
            "$DISCORD_WEBHOOK_URL" || true
